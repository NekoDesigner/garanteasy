/**
 * GDateInput - Generated by Garanteasier CLI
 */

import React, { useState, useRef } from "react";
import { View, Text, TextInput } from "react-native";
import CalendarIcon from "../Icons/CalendarIcon";
import { IGDateInputProps } from "./@types";
import GDateInputStyles from "./styles";

const GDateInput: React.FC<IGDateInputProps> = ({
  style,
  testID = 'gdateinput',
  label,
  labelStyle,
  errorStyle,
  allowFutureDates = true,
  onDateValidation,
  onDateChange,
  onBlur,
  ...props
}) => {
  const [value, setValue] = useState('');
  const [error, setError] = useState<string>('');
  const inputRef = useRef<TextInput>(null);

  // Fonction pour formater la date en DD/MM/YYYY
  const formatDate = (text: string) => {
    // Supprimer tous les caractères non-numériques
    const cleanedText = text.replace(/\D/g, '');

    // Limiter à 8 chiffres maximum
    const limitedText = cleanedText.slice(0, 8);

    // Formater en DD/MM/YYYY
    let formattedDate = '';
    if (limitedText.length >= 1) {
      formattedDate += limitedText.slice(0, 2);
    }
    if (limitedText.length >= 3) {
      formattedDate += '/' + limitedText.slice(2, 4);
    }
    if (limitedText.length >= 5) {
      formattedDate += '/' + limitedText.slice(4, 8);
    }

    return formattedDate;
  };

  // Fonction pour valider si une date existe dans le calendrier
  const isValidDate = (day: number, month: number, year: number): boolean => {
    if (day < 1 || day > 31 || month < 1 || month > 12 || year < 1900) {
      return false;
    }

    const date = new Date(year, month - 1, day);
    return date.getFullYear() === year &&
           date.getMonth() === month - 1 &&
           date.getDate() === day;
  };

  // Fonction pour valider la date complète
  const validateDate = (dateString: string): { isValid: boolean; errorMessage?: string } => {
    // Vérifier le format DD/MM/YYYY
    const dateRegex = /^(\d{2})\/(\d{2})\/(\d{4})$/;
    const match = dateString.match(dateRegex);

    if (!match) {
      return { isValid: false, errorMessage: 'Format invalide. Utilisez DD/MM/YYYY' };
    }

    const day = parseInt(match[1], 10);
    const month = parseInt(match[2], 10);
    const year = parseInt(match[3], 10);

    // Vérifier si la date existe
    if (!isValidDate(day, month, year)) {
      return { isValid: false, errorMessage: 'Date invalide' };
    }

    // Vérifier si la date est dans le futur si non autorisé
    if (!allowFutureDates) {
      const inputDate = new Date(year, month - 1, day);
      const today = new Date();
      today.setHours(0, 0, 0, 0); // Réinitialiser l'heure pour comparer seulement la date

      if (inputDate > today) {
        return { isValid: false, errorMessage: 'Date future non autorisée' };
      }
    }

    return { isValid: true };
  };

  // Gérer le changement de texte
  const handleChangeText = (text: string) => {
    const formattedText = formatDate(text);
    setValue(formattedText);

    // Effacer l'erreur lors de la saisie
    if (error) {
      setError('');
    }

    // Appeler la fonction onChangeText si elle existe
    if (props.onChangeText) {
      props.onChangeText(formattedText);
    }

    if (onDateChange) {
      // Extraire le jour, le mois et l'année du texte formaté
      const parts = formattedText.split('/');
      if (parts.length === 3) {
        const day = parseInt(parts[0], 10);
        const month = parseInt(parts[1], 10);
        const year = parseInt(parts[2], 10);

        // Appeler le callback onDateChange avec la date complète
        onDateChange(new Date(year, month - 1, day));
      }
    }
  };

  // Gérer la perte de focus
  const handleBlur = (event: any) => {
    const validation = validateDate(value);

    if (!validation.isValid && value.length > 0) {
      setError(validation.errorMessage || '');
    } else {
      setError('');
    }

    // Appeler le callback de validation si fourni
    if (onDateValidation) {
      onDateValidation(validation.isValid, validation.errorMessage);
    }

    // Appeler le onBlur original si fourni
    if (onBlur) {
      onBlur(event);
    }
  };

  return (
    <View style={[GDateInputStyles, style]} testID={testID}>
      <Text style={[GDateInputStyles.label, labelStyle]}>{label}</Text>
      <View style={GDateInputStyles.textInputContainer} testID={`${testID}-container`}>
        <TextInput
          ref={inputRef}
          placeholder="DD/MM/YYYY"
          autoCapitalize="none"
          autoCorrect={false}
          testID={`${testID}-input`}
          {...props}
          value={value}
          keyboardType="numeric"
          maxLength={10} // Format DD/MM/YYYY
          style={[
            GDateInputStyles.textInput,
            error ? GDateInputStyles.textInputError : null,
            style
          ]}
          onChangeText={handleChangeText}
          onBlur={handleBlur}
        />
        <CalendarIcon />
      </View>
      {error ? (
        <Text style={[GDateInputStyles.errorText, errorStyle]} testID={`${testID}-error`}>
          {error}
        </Text>
      ) : null}
    </View>
  );
};

export default GDateInput;
