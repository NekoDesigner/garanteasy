/**
 * GDateInput - Generated by Garanteasier CLI
 */

import React, { useState, useRef } from "react";
import { View, Text, TextInput } from "react-native";
import CalendarIcon from "../Icons/CalendarIcon";
import { IGDateInputProps } from "./@types";
import GDateInputStyles from "./styles";

const GDateInput: React.FC<IGDateInputProps> = ({
  style,
  testID = 'gdateinput',
  label,
  labelStyle,
  errorStyle,
  value: initialValue,
  allowFutureDates = true,
  onDateValidation,
  onDateChange,
  onBlur,
  onChangeText, // Extract this to avoid conflicts
  ...props
}) => {
  const [value, setValue] = useState(initialValue || '');
  const [error, setError] = useState<string>('');
  const inputRef = useRef<TextInput>(null);

  // Update internal value when prop changes
  React.useEffect(() => {
    if (initialValue !== undefined) {
      setValue(initialValue);
    }
  }, [initialValue]);

  // Fonction pour formater la date en DD/MM/YYYY
  const formatDate = (text: string, previousValue: string = '') => {
    // Si l'utilisateur supprime tout, retourner une chaîne vide
    if (text === '') {
      return '';
    }

    // Supprimer tous les caractères non-numériques
    const cleanedText = text.replace(/\D/g, '');
    const previousCleanedText = previousValue.replace(/\D/g, '');

    // Si l'utilisateur supprime des caractères numériques, permettre la suppression
    if (cleanedText.length < previousCleanedText.length) {
      // L'utilisateur supprime des caractères, donc formatons juste ce qui reste
      const limitedText = cleanedText.slice(0, 8);

      let formattedDate = '';
      if (limitedText.length >= 1) {
        formattedDate += limitedText.slice(0, 2);
      }
      if (limitedText.length >= 3) {
        formattedDate += '/' + limitedText.slice(2, 4);
      }
      if (limitedText.length >= 5) {
        formattedDate += '/' + limitedText.slice(4, 8);
      }

      return formattedDate;
    }

    // Limiter à 8 chiffres maximum
    const limitedText = cleanedText.slice(0, 8);

    // Formater en DD/MM/YYYY
    let formattedDate = '';
    if (limitedText.length >= 1) {
      formattedDate += limitedText.slice(0, 2);
    }
    if (limitedText.length >= 3) {
      formattedDate += '/' + limitedText.slice(2, 4);
    }
    if (limitedText.length >= 5) {
      formattedDate += '/' + limitedText.slice(4, 8);
    }

    return formattedDate;
  };

  // Fonction pour valider si une date existe dans le calendrier
  const isValidDate = (day: number, month: number, year: number): boolean => {
    if (day < 1 || day > 31 || month < 1 || month > 12 || year < 1900) {
      return false;
    }

    const date = new Date(year, month - 1, day);
    return date.getFullYear() === year &&
           date.getMonth() === month - 1 &&
           date.getDate() === day;
  };

  // Fonction pour valider la date complète
  const validateDate = (dateString: string): { isValid: boolean; errorMessage?: string } => {
    // Vérifier le format DD/MM/YYYY
    const dateRegex = /^(\d{2})\/(\d{2})\/(\d{4})$/;
    const match = dateString.match(dateRegex);

    if (!match) {
      return { isValid: false, errorMessage: 'Format invalide. Utilisez DD/MM/YYYY' };
    }

    const day = parseInt(match[1], 10);
    const month = parseInt(match[2], 10);
    const year = parseInt(match[3], 10);

    // Vérifier si la date existe
    if (!isValidDate(day, month, year)) {
      return { isValid: false, errorMessage: 'Date invalide' };
    }

    // Vérifier si la date est dans le futur si non autorisé
    if (!allowFutureDates) {
      const inputDate = new Date(year, month - 1, day);
      const today = new Date();
      today.setHours(0, 0, 0, 0); // Réinitialiser l'heure pour comparer seulement la date

      if (inputDate > today) {
        return { isValid: false, errorMessage: 'Date future non autorisée' };
      }
    }

    return { isValid: true };
  };

  // Gérer le changement de texte
  const handleChangeText = (text: string) => {
    const formattedText = formatDate(text, value);
    setValue(formattedText);

    // Effacer l'erreur lors de la saisie
    if (error) {
      setError('');
    }

    // Appeler la fonction onChangeText si elle existe
    if (onChangeText) {
      onChangeText(formattedText);
    }

    if (onDateChange) {
      // Extraire le jour, le mois et l'année du texte formaté
      const parts = formattedText.split('/');
      if (parts.length === 3 && parts[0].length === 2 && parts[1].length === 2 && parts[2].length === 4) {
        const day = parseInt(parts[0], 10);
        const month = parseInt(parts[1], 10);
        const year = parseInt(parts[2], 10);

        // Vérifier si la date est valide avant de l'envoyer
        if (isValidDate(day, month, year)) {
          onDateChange(new Date(year, month - 1, day));
        }
      }
    }
  };

  // Gérer la perte de focus
  const handleBlur = (event: any) => {
    const validation = validateDate(value);

    if (!validation.isValid && value.length > 0) {
      setError(validation.errorMessage || '');
    } else {
      setError('');
    }

    // Appeler le callback de validation si fourni
    if (onDateValidation) {
      onDateValidation(validation.isValid, validation.errorMessage);
    }

    // Appeler le onBlur original si fourni
    if (onBlur) {
      onBlur(event);
    }
  };

  return (
    <View style={[GDateInputStyles, style]} testID={testID}>
      <Text style={[GDateInputStyles.label, labelStyle]}>{label}</Text>
      <View style={GDateInputStyles.textInputContainer} testID={`${testID}-container`}>
        <TextInput
          ref={inputRef}
          placeholder="DD/MM/YYYY"
          autoCapitalize="none"
          autoCorrect={false}
          testID={`${testID}-input`}
          {...props}
          value={value}
          keyboardType="numeric"
          maxLength={10} // Format DD/MM/YYYY
          style={[
            GDateInputStyles.textInput,
            error ? GDateInputStyles.textInputError : null,
            style
          ]}
          onChangeText={handleChangeText}
          onBlur={handleBlur}
        />
        <CalendarIcon />
      </View>
      {error ? (
        <Text style={[GDateInputStyles.errorText, errorStyle]} testID={`${testID}-error`}>
          {error}
        </Text>
      ) : null}
    </View>
  );
};

export default GDateInput;
