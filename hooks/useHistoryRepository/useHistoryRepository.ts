/**
 * useHistoryRepository - Generated by Garanteasier CLI
 */

import { SQLiteExecuteAsyncResult, useSQLiteContext } from "expo-sqlite";
import { useCallback } from "react";
import { DatabaseSaveException } from "../../exceptions/DatabaseSaveException";
import { Document } from "../../models/Document/Document";
import { DatabaseDocumentDto } from "../../models/Document/Document.dto";
import { History } from "../../models/History/History";
import { DatabaseHistoryDto } from "../../models/History/History.dto";
import { Item } from "../../models/Item/Item";

export interface IHistoryRepositoryProps {
  ownerId: string;
}

export function useHistoryRepository({ ownerId }: IHistoryRepositoryProps) {
  const db = useSQLiteContext();

  /**
   * Get all history interventions linked to an item
   * @param item Item to get history interventions for
   * @returns Array of history interventions or null if none found
   */
  const getHistoryInterventionsByItem = useCallback(async (item: Item) => {
    const query = `
      SELECT * FROM histories WHERE item_id = ? ORDER BY intervention_date DESC
    `;
    const result = await db.getAllAsync<DatabaseHistoryDto>(query, [item.getId()]);
    if (result) {
      const historiesByItem = result.map((history) => History.toModel<DatabaseHistoryDto, History>(history));
      for (let i = 0; i < historiesByItem.length; i++) {
        const documentsQuery = `SELECT * FROM documents WHERE entity_id = ? AND model = 'History'`;
        const documentsResult = await db.getAllAsync<DatabaseDocumentDto>(documentsQuery, [historiesByItem[i].getId()]);
        if (documentsResult) {
          historiesByItem[i].documents = documentsResult.map((doc) => Document.toModel(doc));
        } else {
          historiesByItem[i].documents = [];
        }
      }
      return historiesByItem;
    }
    return null;
  }, [db]);

  /**
   * Get a history intervention by its ID
   * @param id ID of the history intervention
   * @returns History intervention or null if not found
   */
  const getHistoryInterventionById = useCallback(async (id: string) => {
    const query = `SELECT * FROM histories WHERE id = ?`;
    const documentsQuery = `SELECT * FROM documents WHERE entity_id = ? AND model = 'History'`;
    const historyInterventionResult = await db.getFirstAsync<DatabaseHistoryDto>(query, [id]);
    if (historyInterventionResult) {
      const history = History.toModel<DatabaseHistoryDto, History>(historyInterventionResult);
      const documentsResult = await db.getAllAsync<DatabaseDocumentDto>(documentsQuery, [history.getId()]);
      if (documentsResult) {
        history.documents = documentsResult.map((doc) => Document.toModel(doc));
      } else {
        history.documents = [];
      }
      return history;
    }
    return null;
  }, [db]);

  /**
   * Save or update a history intervention linked to an item
   * @param history History intervention to save
   * @param item Item linked to the history intervention
   * @throws DatabaseSaveException if the save or update fails
   * @return Saved or updated history intervention
   * @description If the history intervention has an ID, it will be updated. Otherwise, a new history intervention will be created.
   */
  const saveHistoryInterventionFromItem = useCallback(async (history: History, item: Item) => {
    let result: SQLiteExecuteAsyncResult<DatabaseHistoryDto>;
    const dbHistoryDto: DatabaseHistoryDto = History.fromModel(history);
    if (dbHistoryDto.id) {
      // UPDATE
      const statement = await db.prepareAsync(
        `UPDATE histories SET
            label = $label,
            item_id = $itemId,
            intervention_date = $interventDate,
            description = $description
        WHERE id = $id
        `);
      result = await statement.executeAsync({
        $id: dbHistoryDto.id,
        $label: dbHistoryDto.label,
        $itemId: item.getId(),
        $interventDate: dbHistoryDto.intervention_date instanceof Date
          ? dbHistoryDto.intervention_date.toISOString()
          : dbHistoryDto.intervention_date,
        $description: dbHistoryDto.description
      });
      if (result.changes === 0) {
        throw new DatabaseSaveException('Failed to update history intervention');
      }
    } else {
      // INSERT
      const statement = await db.prepareAsync(`
        INSERT INTO histories (id, label, item_id, intervention_date, description)
        VALUES ($id, $label, $itemId, $interventionDate, $description)
      `);
      dbHistoryDto.id = History.generateId();
      result = await statement.executeAsync({
        $id: dbHistoryDto.id,
        $label: dbHistoryDto.label,
        $itemId: item.getId(),
        $interventionDate: dbHistoryDto.intervention_date instanceof Date
          ? dbHistoryDto.intervention_date.toISOString()
          : dbHistoryDto.intervention_date,
        $description: dbHistoryDto.description
      });
      if (result.changes === 0) {
        throw new DatabaseSaveException('Failed to create history intervention');
      }
    }
    return history;
  }, [db]);

  return { getHistoryInterventionsByItem, getHistoryInterventionById, saveHistoryInterventionFromItem };
}
