/**
 * useNotificationsRepository - Generated by Garanteasier CLI
 */

import * as Notifications from 'expo-notifications';
import { useSQLiteContext } from "expo-sqlite";
import React from "react";
import { Item } from '../../models/Item/Item';
import { Notification } from '../../models/Notification/Notification';
import { DatabaseNotificationDto } from '../../models/Notification/Notification.dto';

export function useNotificationsRepository() {
  const db = useSQLiteContext();

  const createNotification = React.useCallback(async ({ scheduleTime, title, body, data }: {
    scheduleTime: Date,
    title: string,
    body: string,
    data?: Record<string, any>
  }) => {
    if (!db) {
      throw new Error("Database connection is not established.");
    }

    const identifier = await Notifications.scheduleNotificationAsync({
      content: {
        title,
        body,
        data: data || {},
      },
      trigger: {
        type: Notifications.SchedulableTriggerInputTypes.TIME_INTERVAL,
        // Convert scheduleTime to a timestamp in seconds
        seconds: Math.max(1, Math.floor((scheduleTime.getTime() - Date.now()) / 1000)),
        repeats: false, // Set to true if you want the notification to repeat
      }
    });

    const query = `
      INSERT INTO notifications (title, body, data, device_notification_id, scheduled_time)
      VALUES (?, ?, ?, ?, ?);
    `;
    // Replace with your own DTO transformation or remove if unnecessary
    const notificationDto = {
      title,
      body,
      data: data || {},
      device_notification_id: identifier,
      scheduled_time: new Date().toISOString(),
    };
    db.runAsync(query, [
      notificationDto.title,
      notificationDto.body,
      JSON.stringify(notificationDto.data),
      notificationDto.device_notification_id,
      notificationDto.scheduled_time,
    ]);

    return identifier;

  }, [db]);

  const recreateNotifications = React.useCallback(async (notifications: Notification[]) => {
    const promises = [];
    for (const notification of notifications) {
      promises.push(createNotification({
        scheduleTime: notification.scheduledTime || new Date(),
        title: notification.title,
        body: notification.body,
        data: notification.data
      }));
    }
    await Promise.all(promises);
  }, [createNotification]);

  const getNotification = React.useCallback(async (deviceNotificationId: string): Promise<Notification | null> => {
    if (!db) {
      throw new Error("Database connection is not established.");
    }
    const query = `SELECT * FROM notifications WHERE device_notification_id = ?;`;
    const result = await db.getFirstAsync<DatabaseNotificationDto>(query, [deviceNotificationId]);
    if (result) {
      return Notification.toModel<DatabaseNotificationDto, Notification>(result);
    }
    return null;
  }, [db]);

  const getNotificationByItem = React.useCallback(async (itemId: string): Promise<Notification | null> => {
    // Since data is a JSON string, we need to search for the itemId inside it.
    // This uses a LIKE query to match the itemId as a substring in the data column.
    const query = `SELECT * FROM notifications WHERE data LIKE ?;`;
    const likePattern = `%itemId: ${itemId}%`;
    const result = await db.getFirstAsync<DatabaseNotificationDto>(query, [likePattern]);
    if (result) {
      return Notification.toModel<DatabaseNotificationDto, Notification>(result);
    }
    return null;
  }, [db]);

  const removeNotification = React.useCallback(async (notification: Notification | string) => {
    if (!db) {
      throw new Error("Database connection is not established.");
    }
    try {
      const identifier = typeof notification === 'string' ? notification : notification.deviceNotificationId;
      const query = `DELETE FROM notifications WHERE device_notification_id = ?;`;
      await db.runAsync(query, [identifier]);
      await Notifications.cancelScheduledNotificationAsync(identifier);
    } catch {
      console.warn(`Failed to remove notification with identifier: ${typeof notification === 'string' ? notification : notification.deviceNotificationId}`);
    }
  }, [db]);

  const removeNotificationByItem = React.useCallback(async (item: Item) => {
    const notification = await getNotificationByItem(item.getId());
    if (notification) {
      await removeNotification(notification);
    }
  }, [getNotificationByItem, removeNotification]);

  const removeAllNotifications = React.useCallback(async () => {
    if (!db) {
      throw new Error("Database connection is not established.");
    }
    const query = `DELETE FROM notifications;`;
    await db.runAsync(query);
    await Notifications.cancelAllScheduledNotificationsAsync();
  }, [db]);

  return {
    createNotification,
    removeNotification,
    getNotification,
    removeAllNotifications,
    recreateNotifications,
    getNotificationByItem,
    removeNotificationByItem
  };
}
