/**
 * useItemRepository - Generated by Garanteasier CLI
 */

import { SQLiteExecuteAsyncResult, useSQLiteContext } from "expo-sqlite";
import { Item } from "../../models/Item/Item";
import { DatabaseItemDto } from "../../models/Item/Item.dto";

export interface IItemRepositoryProps {
  ownerId: string;
}

export function useItemRepository(props: IItemRepositoryProps) {
  const db = useSQLiteContext();
  async function getAllItems(): Promise<Item[]> {
    const query = `SELECT * FROM items WHERE owner_id = ?`;
    const result = await db.getAllAsync<DatabaseItemDto>(query, [props.ownerId]);
    const items: Item[] = result.map((item) => Item.toModel(item));
    console.log("Fetched items:", items);
    return items;
  }
  async function getItemById(id: string): Promise<Item | null> {
    const query = `SELECT * FROM items WHERE id = ? AND owner_id = ?`;
    const result = await db.getFirstAsync<DatabaseItemDto>(query, [id, props.ownerId]);
    if (result) {
      return Item.toModel(result);
    }
    return null;
  }
  async function saveItem(item: Item): Promise<Item> {
    let result: SQLiteExecuteAsyncResult<DatabaseItemDto>;
    const dbItemDto: DatabaseItemDto = Item.fromModel(item);
    if (dbItemDto.id) {
      // UPDATE
      const statement = await db.prepareAsync(
        `UPDATE items SET 
            label = $label, 
            category_id = $category_id, 
            owner_id = $owner_id, 
            purchase_date = $purchase_date, 
            warranty_duration = $warranty_duration, 
            memo = $memo,
            updated_at = CURRENT_TIMESTAMP
          WHERE id = $id AND owner_id = $owner_id`
      );
      result = await statement.executeAsync({
        $id: dbItemDto.id,
        $label: dbItemDto.label,
        $category_id: dbItemDto.category_id,
        $owner_id: props.ownerId,
        $purchase_date: dbItemDto.purchase_date instanceof Date
          ? dbItemDto.purchase_date.toISOString()
          : dbItemDto.purchase_date,
        $warranty_duration: dbItemDto.warranty_duration,
        $memo: dbItemDto.memo || ""
      });
      if (result.changes === 0) {
        throw new Error(`Item with id ${dbItemDto.id} not found or not owned by user ${props.ownerId}`);
      }
      // Return the updated item
      const updatedItem = await getItemById(dbItemDto.id);
      if (updatedItem) {
        return updatedItem;
      }
      throw new Error(`Failed to update item with id ${dbItemDto.id}`);
    } else {
      // INSERT
      const id = Item.generateId();
      const statement = await db.prepareAsync(
        `INSERT INTO items (
            id, 
            label, 
            category_id, 
            owner_id,
            purchase_date,
            warranty_duration,
            memo,
        ) VALUES ($id, $label, $category_id, $owner_id, $purchase_date, $warranty_duration, $memo)`
      );
      result = await statement.executeAsync({
        $id: id,
        $label: dbItemDto.label,
        $category_id: dbItemDto.category_id,
        $owner_id: props.ownerId,
        $purchase_date: dbItemDto.purchase_date instanceof Date
          ? dbItemDto.purchase_date.toISOString()
          : dbItemDto.purchase_date,
        $warranty_duration: dbItemDto.warranty_duration,
        $memo: dbItemDto.memo || ""
      });
    }
    const firstRow = await result.getFirstAsync();
    if (firstRow) {
      return Item.toModel(firstRow);
    }
    throw new Error("Failed to save item");
  }

  return {
    getAllItems,
    getItemById,
    saveItem
  };
}
