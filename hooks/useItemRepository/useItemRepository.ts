/**
 * useItemRepository - Generated by Garanteasier CLI
 */

import { SQLiteExecuteAsyncResult, useSQLiteContext } from "expo-sqlite";
import React from "react";
import { DatabaseSaveException } from "../../exceptions/DatabaseSaveException";
import { Category } from "../../models/Category/Category";
import { DatabaseCategoryDto } from "../../models/Category/Category.dto";
import { Document } from "../../models/Document/Document";
import { DatabaseDocumentDto } from "../../models/Document/Document.dto";
import { History } from "../../models/History/History";
import { DatabaseHistoryDto } from "../../models/History/History.dto";
import { Item } from "../../models/Item/Item";
import { DatabaseItemDto } from "../../models/Item/Item.dto";
import { Notification } from "../../models/Notification/Notification";
import { DateService } from "../../services/DateService";
import { ImageService } from "../../services/ImageService";
import { useDocumentRepository } from "../useDocumentRepository/useDocumentRepository";
import { useNotificationsRepository } from "../useNotificationsRepository/useNotificationsRepository";

export interface IItemRepositoryProps {
  ownerId: string;
}

export function useItemRepository(props: IItemRepositoryProps) {
  const db = useSQLiteContext();
  const { createNotification, removeNotificationByItem, removeNotification } = useNotificationsRepository();
  const { deleteDocumentById, detachDocumnentFromItem } = useDocumentRepository({ ownerId: props.ownerId });

  const getAllItems = React.useCallback(async (options: { withArchived?: boolean, withDocuments?: boolean, withNotification?: boolean, byCategoryIds?: string[], byLabelOrBrand?: string; } = {}): Promise<Item[]> => {
    const dynamicProps = [];
    let query = `SELECT * FROM items WHERE owner_id = ? `;
    dynamicProps.push(props.ownerId);
    if (!options.withArchived) {
      query += 'AND is_archived = 0 ';
    }
    if (options.byCategoryIds && options.byCategoryIds.length > 0) {
      query += `AND category_id IN (${options.byCategoryIds.map(() => '?').join(', ')}) `;
      dynamicProps.push(...options.byCategoryIds);
    }
    if (options.byLabelOrBrand) {
      query += `AND (label LIKE ? OR brand LIKE ?) `;
      dynamicProps.push(`%${options.byLabelOrBrand}%`, `%${options.byLabelOrBrand}%`);
    }
    query += 'ORDER BY created_at DESC';

    if (options.byLabelOrBrand) {
      console.log("QUERY => ", query);
    }
    const result = await db.getAllAsync<DatabaseItemDto>(query, dynamicProps);
    let items: Item[] = result.map((item) => Item.toModel(item));

    for (const item of items) {
      const categoryDatabaseDto = await db.getFirstAsync<DatabaseCategoryDto>(`SELECT * FROM categories WHERE id = ? AND owner_id = ?`, [item.categoryId, item.ownerId]);
      let category: Category | null = null;
      if (categoryDatabaseDto) {
        category = Category.toModel<DatabaseCategoryDto, Category>(categoryDatabaseDto);
      }
      item.category = category;
    }

    if (options.withDocuments) {
      const itemIds = items.map(item => item.id).filter(id => id !== undefined) as string[];

      if (itemIds.length > 0) {
        const documents = await db.getAllAsync<DatabaseDocumentDto>(
          `SELECT
            documents.*,
            document_attachments.model as "entity_model",
            document_attachments.entity_id as "entity_id"
          FROM documents
            INNER JOIN document_attachments ON documents.id = document_attachments.document_id
            WHERE document_attachments.entity_id IN (${itemIds.map(() => '?').join(', ')}) AND document_attachments.model = 'Item'`,
          itemIds
        );

        // Attach documents to their respective items
        documents.forEach((doc) => {
          const item = items.find(item => item.id === doc.entity_id);
          if (item) {
            // Initialize documents array if it doesn't exist
            if (!item.documents) {
              item.documents = [];
            }
            const document = Document.toModel<DatabaseDocumentDto, Document>(doc);
            item.documents.push(document);
          }
        });
      }
    }

    if (options.withNotification) {
      const dbNotifications = await db.getAllAsync<DatabaseItemDto>(`SELECT * FROM notifications`);
      const notifications = dbNotifications.map(notification => Notification.toModel<DatabaseItemDto, Notification>(notification));
      items.forEach(item => {
        item.notifications = notifications.filter(notification => notification.data?.itemId === item.id && notification.data?.itemOwnerId === props.ownerId);
      });
    }

    return items;
  }, [db, props.ownerId]);

  const getItemsDocuments = React.useCallback(async (itemIds: string[]): Promise<DatabaseDocumentDto[]> => {
    return await db.getAllAsync<DatabaseDocumentDto>(
          `SELECT
            documents.*,
            document_attachments.model as "entity_model",
            document_attachments.entity_id as "entity_id"
          FROM documents
            INNER JOIN document_attachments ON documents.id = document_attachments.document_id
            WHERE document_attachments.entity_id IN (${itemIds.map(() => '?').join(', ')}) AND document_attachments.model = 'Item'`,
          itemIds
        );
  }, [db]);

  const isDocumentAttachedToOtherItem = React.useCallback(async (documentId: string, currentItemId: string) => {
    const query = `SELECT * FROM document_attachments WHERE document_id = ? AND entity_id != ?`;
    const result = await db.getAllAsync(query, [documentId, currentItemId]);
    return result.length > 0;
  }, [db]);

  const getItemById = React.useCallback(
    async (id: string): Promise<Item | null> => {
      const query = `SELECT * FROM items WHERE id = ? AND owner_id = ?`;
      const result = await db.getFirstAsync<DatabaseItemDto>(query, [id, props.ownerId]);
      if (result) {
        const documents = await db.getAllAsync<DatabaseDocumentDto>(`SELECT
            documents.*,
            document_attachments.model as "entity_model",
            document_attachments.entity_id as "entity_id"
          FROM documents
            INNER JOIN document_attachments ON documents.id = document_attachments.document_id
            WHERE document_attachments.entity_id = ? AND document_attachments.model = 'Item'`, [id]);

        const categoryDatabaseDto = await db.getFirstAsync<DatabaseCategoryDto>(`SELECT * FROM categories WHERE id = ? AND owner_id = ?`, [result.category_id, result.owner_id]);
        let category: Category | null = null;
        if (categoryDatabaseDto) {
          category = Category.toModel<DatabaseCategoryDto, Category>(categoryDatabaseDto);
        }

        const interventionsDto = await db.getAllAsync<DatabaseHistoryDto>(`SELECT * FROM histories WHERE item_id = ?`, [id]);
        let interventions: History[] = [];
        if (interventionsDto.length > 0) {
          interventions = interventionsDto.map(intervention => History.toModel<DatabaseHistoryDto, History>(intervention));
          const interventionIds = interventions.map(i => i.getId());
          console.log('🔍 Intervention IDs to search:', interventionIds);
          console.log('🔍 Generated SQL placeholders:', interventionIds.map(() => '?').join(', '));

          const documents = await db.getAllAsync<DatabaseDocumentDto>(`SELECT
            documents.*,
            document_attachments.model as "entity_model",
            document_attachments.entity_id as "entity_id"
          FROM documents
            INNER JOIN document_attachments ON documents.id = document_attachments.document_id
            WHERE document_attachments.entity_id IN (${interventionIds.map(() => '?').join(', ')}) AND document_attachments.model = 'History'`,
            interventionIds
          );
          // Attach documents to their respective history interventions
          for (const intervention of interventions) {
            intervention.documents = documents.filter(doc => doc.entity_id === intervention.getId()).map(doc => Document.toModel<DatabaseDocumentDto, Document>(doc)) ?? [];
          }
        }

        const item = Item.toModel<DatabaseItemDto, Item>(result);
        item.documents = documents.map(doc => Document.toModel<DatabaseDocumentDto, Document>(doc));
        item.interventions = interventions;
        item.category = category;
        return item;
      }
      return null;
    },
    [db, props.ownerId]
  );
  const saveItem = React.useCallback(
    async (item: Item): Promise<Item> => {
      let result: SQLiteExecuteAsyncResult<DatabaseItemDto>;
      item = Item.setItemIsArchived(item);
      const dbItemDto: DatabaseItemDto = Item.fromModel(item);
      let savedItem: Item | null = null;

      if (dbItemDto.id) {
        // UPDATE
        const statement = await db.prepareAsync(
          `UPDATE items SET 
              label = $label, 
              brand = $brand,
              category_id = $category_id, 
              owner_id = $owner_id, 
              picture = $picture,
              purchase_date = $purchase_date, 
              warranty_duration = $warranty_duration, 
              memo = $memo,
              is_archived = $is_archived,
              updated_at = CURRENT_TIMESTAMP
            WHERE id = $id AND owner_id = $owner_id`
        );
        result = await statement.executeAsync({
          $id: dbItemDto.id,
          $label: dbItemDto.label,
          $brand: dbItemDto.brand || null,
          $category_id: dbItemDto.category_id,
          $owner_id: props.ownerId,
          $picture: dbItemDto.picture || null,
          $purchase_date: dbItemDto.purchase_date instanceof Date
            ? dbItemDto.purchase_date.toISOString()
            : dbItemDto.purchase_date,
          $warranty_duration: dbItemDto.warranty_duration,
          $memo: dbItemDto.memo || null,
          $is_archived: dbItemDto.is_archived ? 1 : 0
        });
        if (result.changes === 0) {
          throw new DatabaseSaveException(`Item with id ${dbItemDto.id} not found or not owned by user ${props.ownerId}`);
        }
        // Return the updated item
        const updatedItem = await getItemById(dbItemDto.id);
        if (updatedItem) {
          savedItem = updatedItem;
          removeNotificationByItem(updatedItem);
          // Create a new notification for the updated item
          await createNotification({
            scheduleTime: DateService.scheduleTimeNotificationDateByItem(updatedItem),
            title: `Une garanties arrive à expiration bientôt !`,
            body: `La garrantie de votre ${dbItemDto.label} va bientôt expirer 🔔.`,
            data: {
              itemId: updatedItem.id,
              itemLabel: dbItemDto.label,
              itemOwnerId: props.ownerId
            }
          });
        } else {
          throw new Error(`Failed to update item with id ${dbItemDto.id}`);
        }
      } else {
        // INSERT
        let id = Item.generateId();
        item.id = id;
        let identifier: string | null = null;

        // Retry with different ID if there's a collision
        let attempts = 0;
        const maxAttempts = 3;

        while (attempts < maxAttempts) {
          try {
            const statement = await db.prepareAsync(
              `INSERT INTO items (
                  id, 
                  label, 
                  brand,
                  category_id, 
                  owner_id,
                  picture,
                  purchase_date,
                  warranty_duration,
                  memo,
                  is_archived
              ) VALUES ($id, $label, $brand, $category_id, $owner_id, $picture, $purchase_date, $warranty_duration, $memo, $is_archived)`
            );
            result = await statement.executeAsync({
              $id: id,
              $label: dbItemDto.label,
              $brand: dbItemDto.brand || null,
              $category_id: dbItemDto.category_id,
              $owner_id: props.ownerId,
              $picture: dbItemDto.picture || null,
              $purchase_date: dbItemDto.purchase_date instanceof Date
                ? dbItemDto.purchase_date.toISOString()
                : dbItemDto.purchase_date,
              $warranty_duration: dbItemDto.warranty_duration,
              $memo: dbItemDto.memo || null,
              $is_archived: dbItemDto.is_archived ? 1 : 0
            });

            // If we get here, the insert was successful
            break;
          } catch (error) {
            attempts++;
            if (identifier) {
              await removeNotification(identifier);
            }
            if (error instanceof Error && error.message.includes('UNIQUE constraint failed')) {
              if (attempts < maxAttempts) {
                // Generate a new ID and try again
                id = Item.generateId();
                continue;
              }
            }
            // If it's not a UNIQUE constraint error, or we've exceeded max attempts, rethrow
            throw error;
          }
        }

        // For INSERT operations, fetch the newly created item
        const newItem = await getItemById(id);
        if (newItem) {
          savedItem = newItem;
        } else {
          throw new DatabaseSaveException("Failed to save item");
        }
      }

      // Create a notification for the new item
      await createNotification({
        scheduleTime: DateService.scheduleTimeNotificationDateByItem(item),
        title: `Une garanties arrive à expiration bientôt !`,
        body: `La garrantie de votre ${dbItemDto.label} va bientôt expirer 🔔.`,
        data: {
          itemId: item.id,
          itemLabel: dbItemDto.label,
          itemOwnerId: props.ownerId
        }
      });

      return savedItem || item;
    },
    [createNotification, props.ownerId, db, getItemById, removeNotificationByItem, removeNotification]
  );

  const deleteItem = React.useCallback(async (item: Item) => {
    return await db.withTransactionAsync(async () => {
      const documents = await getItemsDocuments([item.getId()]);
      for (const document of documents) {
        if (!document.id) {
          throw new Error(`Document with id ${document.id} not found`);
        }
        await detachDocumnentFromItem(document.id, item.getId());
        await deleteDocumentById(document.id);
      }
      const statement = await db.prepareAsync(`DELETE FROM items WHERE id = $itemId AND owner_id = $ownerId`);
      try {
        statement.executeAsync({
          $itemId: item.getId(),
          $ownerId: props.ownerId
        });
      } catch (error) {
        console.error('Error deleting item:', error);
        throw new DatabaseSaveException(`Failed to delete item with id ${item.getId()} for user ${props.ownerId}`);
      }

      // Supprimer les notifications associées
      await removeNotificationByItem(item);

      // Supprimer les fichiers attachés (Vérifier si ces fichiers sont utilisé par d'autres objets)
      for (const document of documents) {
        if (document.file_source === 'local' && document.file_path) {
          if (!document.id) {
            throw new Error(`Document with id ${document.id} not found`);
          }
          const isDeletable = await isDocumentAttachedToOtherItem(document.id, item.getId());
          try {
            if (isDeletable) {
              await ImageService.deleteImage(document.file_path);
            }
          } catch (err) {
            console.warn(`Failed to remove file at ${document.file_path}:`, err);
          }
        }
      }
    });
  }, [db, getItemsDocuments, removeNotificationByItem, detachDocumnentFromItem, deleteDocumentById, props.ownerId, isDocumentAttachedToOtherItem]);

  return React.useMemo(() => ({
    getAllItems,
    getItemById,
    saveItem,
    deleteItem
  }), [getAllItems, getItemById, saveItem, deleteItem]);
}
