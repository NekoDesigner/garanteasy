/**
 * useItemRepository - Generated by Garanteasier CLI
 */

import { SQLiteExecuteAsyncResult, useSQLiteContext } from "expo-sqlite";
import React from "react";
import { DatabaseSaveException } from "../../exceptions/DatabaseSaveException";
import { Category } from "../../models/Category/Category";
import { DatabaseCategoryDto } from "../../models/Category/Category.dto";
import { Document } from "../../models/Document/Document";
import { DatabaseDocumentDto } from "../../models/Document/Document.dto";
import { Item } from "../../models/Item/Item";
import { DatabaseItemDto } from "../../models/Item/Item.dto";

export interface IItemRepositoryProps {
  ownerId: string;
}

export function useItemRepository(props: IItemRepositoryProps) {
  const db = useSQLiteContext();

  const getAllItems = React.useCallback(async (options: { withArchived?: boolean, withDocuments?: boolean } = {}): Promise<Item[]> => {
    let query = `SELECT * FROM items WHERE owner_id = ? `;
    if (!options.withArchived) {
      query += 'AND is_archived = 0 ';
    }
    query += 'ORDER BY created_at DESC';
    const result = await db.getAllAsync<DatabaseItemDto>(query, [props.ownerId]);
    let items: Item[] = result.map((item) => Item.toModel(item));

    for (const item of items) {
      const categoryDatabaseDto = await db.getFirstAsync<DatabaseCategoryDto>(`SELECT * FROM categories WHERE id = ? AND owner_id = ?`, [item.categoryId, item.ownerId]);
      let category: Category | null = null;
      if (categoryDatabaseDto) {
        category = Category.toModel<DatabaseCategoryDto, Category>(categoryDatabaseDto);
      }
      item.category = category;
    }

    if (options.withDocuments) {
      const itemIds = items.map(item => item.id).filter(id => id !== undefined) as string[];

      if (itemIds.length > 0) {
        const documents = await db.getAllAsync<DatabaseDocumentDto>(
          `SELECT
            documents.*,
            document_attachments.model as "entity_model",
            document_attachments.entity_id as "entity_id"
          FROM documents
            INNER JOIN document_attachments ON documents.id = document_attachments.document_id
            WHERE document_attachments.entity_id IN (${itemIds.map(() => '?').join(', ')}) AND document_attachments.model = 'Item'`,
          itemIds
        );

        // Attach documents to their respective items
        documents.forEach((doc) => {
          const item = items.find(item => item.id === doc.entity_id);
          if (item) {
            // Initialize documents array if it doesn't exist
            if (!item.documents) {
              item.documents = [];
            }
            const document = Document.toModel<DatabaseDocumentDto, Document>(doc);
            item.documents.push(document);
          }
        });
      }
    }
    return items;
  }, [db, props.ownerId]);

  const getItemById = React.useCallback(
    async (id: string): Promise<Item | null> => {
      const query = `SELECT * FROM items WHERE id = ? AND owner_id = ?`;
      const result = await db.getFirstAsync<DatabaseItemDto>(query, [id, props.ownerId]);
      if (result) {
        const documents = await db.getAllAsync<DatabaseDocumentDto>(`SELECT
            documents.*,
            document_attachments.model as "entity_model",
            document_attachments.entity_id as "entity_id"
          FROM documents
            INNER JOIN document_attachments ON documents.id = document_attachments.document_id
            WHERE document_attachments.entity_id = ? AND document_attachments.model = 'Item'`, [id]);

        const categoryDatabaseDto = await db.getFirstAsync<DatabaseCategoryDto>(`SELECT * FROM categories WHERE id = ? AND owner_id = ?`, [result.category_id, result.owner_id]);
        let category: Category | null = null;
        if (categoryDatabaseDto) {
          category = Category.toModel<DatabaseCategoryDto, Category>(categoryDatabaseDto);
        }

        const item = Item.toModel<DatabaseItemDto, Item>(result);
        item.documents = documents.map(doc => Document.toModel<DatabaseDocumentDto, Document>(doc));
        item.category = category;
        return item;
      }
      return null;
    },
    [db, props.ownerId]
  );
  const saveItem = React.useCallback(
    async (item: Item): Promise<Item> => {
      let result: SQLiteExecuteAsyncResult<DatabaseItemDto>;
      item = Item.setItemIsArchived(item);
      const dbItemDto: DatabaseItemDto = Item.fromModel(item);

      if (dbItemDto.id) {
        // UPDATE
        const statement = await db.prepareAsync(
          `UPDATE items SET 
              label = $label, 
              brand = $brand,
              category_id = $category_id, 
              owner_id = $owner_id, 
              picture = $picture,
              purchase_date = $purchase_date, 
              warranty_duration = $warranty_duration, 
              memo = $memo,
              is_archived = $is_archived,
              updated_at = CURRENT_TIMESTAMP
            WHERE id = $id AND owner_id = $owner_id`
        );
        result = await statement.executeAsync({
          $id: dbItemDto.id,
          $label: dbItemDto.label,
          $brand: dbItemDto.brand || null,
          $category_id: dbItemDto.category_id,
          $owner_id: props.ownerId,
          $picture: dbItemDto.picture || null,
          $purchase_date: dbItemDto.purchase_date instanceof Date
            ? dbItemDto.purchase_date.toISOString()
            : dbItemDto.purchase_date,
          $warranty_duration: dbItemDto.warranty_duration,
          $memo: dbItemDto.memo || null,
          $is_archived: dbItemDto.is_archived ? 1 : 0
        });
        if (result.changes === 0) {
          throw new DatabaseSaveException(`Item with id ${dbItemDto.id} not found or not owned by user ${props.ownerId}`);
        }
        // Return the updated item
        const updatedItem = await getItemById(dbItemDto.id);
        if (updatedItem) {
          return updatedItem;
        }
        throw new Error(`Failed to update item with id ${dbItemDto.id}`);
      } else {
        // INSERT
        let id = Item.generateId();

        // Retry with different ID if there's a collision
        let attempts = 0;
        const maxAttempts = 3;

        while (attempts < maxAttempts) {
          try {
            const statement = await db.prepareAsync(
              `INSERT INTO items (
                  id, 
                  label, 
                  brand,
                  category_id, 
                  owner_id,
                  picture,
                  purchase_date,
                  warranty_duration,
                  memo,
                  is_archived
              ) VALUES ($id, $label, $brand, $category_id, $owner_id, $picture, $purchase_date, $warranty_duration, $memo, $is_archived)`
            );
            result = await statement.executeAsync({
              $id: id,
              $label: dbItemDto.label,
              $brand: dbItemDto.brand || null,
              $category_id: dbItemDto.category_id,
              $owner_id: props.ownerId,
              $picture: dbItemDto.picture || null,
              $purchase_date: dbItemDto.purchase_date instanceof Date
                ? dbItemDto.purchase_date.toISOString()
                : dbItemDto.purchase_date,
              $warranty_duration: dbItemDto.warranty_duration,
              $memo: dbItemDto.memo || null,
              $is_archived: dbItemDto.is_archived ? 1 : 0
            });

            // If we get here, the insert was successful
            break;
          } catch (error) {
            attempts++;

            if (error instanceof Error && error.message.includes('UNIQUE constraint failed')) {
              if (attempts < maxAttempts) {
                // Generate a new ID and try again
                id = Item.generateId();
                continue;
              }
            }
            // If it's not a UNIQUE constraint error, or we've exceeded max attempts, rethrow
            throw error;
          }
        }

        // For INSERT operations, fetch the newly created item
        const newItem = await getItemById(id);
        if (newItem) {
          return newItem;
        }
        throw new DatabaseSaveException("Failed to save item");
      }
    },
    [db, props.ownerId, getItemById]
  );
  return React.useMemo(() => ({
    getAllItems,
    getItemById,
    saveItem
  }), [getAllItems, getItemById, saveItem]);
}
